var LatLon = require('geodesy').LatLonSpherical;
var mo = require('./movable-object.js');


// Usage: init this object and call .start(callback) function.
// 
// Parameters:
// 		route: 		required
// 		objectName: optional
// 		interval: 	optional
//
// route = [
//		{
//			from_location:  { longitude, latitude },
//			to_location: 	{ longitude, latitude },
//			acceleration
//		}
// ]
//
// callback(position, beStopped, movableObject)
// 
// position:
// {
//   	longitude: 105.83762177972369,
//   	latitude: 21.030965222197796
// }
var DEBUG = true;

exports.GpsSimulator = function (route, objectName, interval, fastFoward) {

	// route must be provided
	if (route == null || route.length < 1) return;
	var _route = route;

	if (interval == null || interval < 1000) {
		logInfo('Set interval to minimum 1000 milliseconds');
		interval = 1000;
	}
	var _interval = interval;

	if (objectName == null || objectName.length == 0) {
		objectName = 'Object';
	}
	var _objectName = objectName;
	var _fastFoward = fastFoward;
	if (_fastFoward == null || _fastFoward < 1) {
		fastFoward = 1;
	}

	function logInfo(info) {
		if (DEBUG == true)
			console.log('[' + _objectName + '] ' + info);
	}
	const amqp = require('amqplib')

var channel, connection;  //global variables
async function connectQueue() {   
    try {
        connection = await amqp.connect("amqp://localhost:5672");
        channel    = await connection.createChannel()
        
        await channel.assertQueue("test-queue")
        
    } catch (error) {
        console.log(error)
    }
}
connectQueue();
async function sendData (data, callback) {
    // send data to queue
    await channel.sendToQueue("test-queue", Buffer.from(JSON.stringify(data)));
        
    // close the channel and connection
    // await channel.close();
    // await connection.close(); 
	if (callback) callback(movableObject.position, false, movableObject, currentRouteIndex);
}


	// Calculate distances for each route
	for (var i = 0; i < _route.length; i++) {
		var item = _route[i];
		var p1 = new LatLon(item.from_location.latitude, item.from_location.longitude);
		var p2 = new LatLon(item.to_location.latitude, item.to_location.longitude);
		item.distance = p1.distanceTo(p2);
		item.bearing = p1.bearingTo(p2);
	}
	logInfo('Will move in route:');
	if (DEBUG == true) {
		console.log(_route);
	}

	logInfo('Will be sampling info after each ' + _interval / 1000 + ' second(s)');


	// ++ Logic
	var movableObject = null;
	var currentRouteIndex = null;
	var currentRoute = null;

	function beginRoute(callback) {
		// Determine new route index
		if (currentRouteIndex == null) {
			currentRouteIndex = 0;
		} else {
			currentRouteIndex += 1;
		}

		if (currentRouteIndex < _route.length) {
			logInfo('Begin route with index ' + currentRouteIndex);

			currentRoute = _route[currentRouteIndex];
			movableObject.setPosition(currentRoute.from_location.longitude, currentRoute.from_location.latitude);
			movableObject.setAcceleration(currentRoute.acceleration);
			movableObject.setBearing(currentRoute.bearing);
		}

		if (callback) callback(movableObject.position, false, movableObject, currentRouteIndex);

		return (currentRouteIndex < _route.length);
	}

	
	var _countDown = null;
	
	function moveObject(duration, callback) {
		logInfo('------------------------------------------');
		logInfo('Move after ' + duration + ' seconds');
		
		var beStopped = false;

		movableObject.move(duration);
			
		// Check if start new route item
		var distanceFromBeginRoute = movableObject.distanceTo(currentRoute.from_location.longitude, currentRoute.from_location.latitude);
		if (distanceFromBeginRoute >= currentRoute.distance) {
			if (beginRoute() == false)
				beStopped = true;
		}

		if (beStopped) {
			stopObject(callback);
		} else {
			sendData(movableObject.position, callback);
			
		}
	}
	// -- Logic


	var _intervalId = null;

	this.start = function(callback) {
		logInfo('Start moving');

		movableObject = new mo.MovableObject();

		currentRouteIndex = null;

		beginRoute(callback);

		_intervalId = setInterval(function() {

			moveObject(_interval / 1000, callback);
			

		}, _interval / fastFoward);
	}

	function stopObject(callback) {
		logInfo('Stop moving');
		if (_intervalId) {
			clearInterval(_intervalId);
		}

		if (callback) callback(movableObject.position, true, movableObject, currentRouteIndex);
	}
	
	this.stop = function(callback) {
		stopObject(callback);
	}

}
